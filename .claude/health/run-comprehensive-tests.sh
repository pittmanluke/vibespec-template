#!/bin/bash

# Comprehensive Multi-Agent Workflow Integration Test Runner
# Orchestrates all testing components for complete system validation

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
BASE_PATH="${1:-$(pwd)}"
CLAUDE_PATH="$BASE_PATH/.claude"
HEALTH_PATH="$CLAUDE_PATH/health"
LOG_FILE="$HEALTH_PATH/test-execution-$(date +%Y%m%d-%H%M%S).log"
RESULTS_DIR="$HEALTH_PATH/results"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)

# Ensure required directories exist
mkdir -p "$HEALTH_PATH" "$RESULTS_DIR"

# Logging function
log() {
    echo -e "$1" | tee -a "$LOG_FILE"
}

# Function to check prerequisites
check_prerequisites() {
    log "${BLUE}üîç Checking Prerequisites...${NC}"
    
    # Check Python availability
    if ! command -v python3 &> /dev/null; then
        log "${RED}‚ùå Python 3 is required but not installed${NC}"
        exit 1
    fi
    
    # Check required Python packages
    log "   üì¶ Checking Python packages..."
    python3 -c "import psutil, json, threading, concurrent.futures" 2>/dev/null || {
        log "${YELLOW}‚ö†Ô∏è  Installing required Python packages...${NC}"
        python3 -m pip install psutil --quiet || {
            log "${RED}‚ùå Failed to install required packages${NC}"
            exit 1
        }
    }
    
    # Check Claude system structure
    log "   üìÅ Verifying Claude system structure..."
    required_dirs=("$CLAUDE_PATH/agents" "$CLAUDE_PATH/commands" "$CLAUDE_PATH/hooks" "$CLAUDE_PATH/scripts" "$CLAUDE_PATH/workflow-state")
    
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log "${YELLOW}‚ö†Ô∏è  Creating missing directory: $dir${NC}"
            mkdir -p "$dir"
        fi
    done
    
    # Check test scripts exist
    test_scripts=(
        "$HEALTH_PATH/integration-test-suite.py"
        "$HEALTH_PATH/performance-benchmarks.py"
        "$HEALTH_PATH/load-test-runner.py"
    )
    
    for script in "${test_scripts[@]}"; do
        if [[ ! -f "$script" ]]; then
            log "${RED}‚ùå Required test script not found: $script${NC}"
            exit 1
        fi
        chmod +x "$script"
    done
    
    log "${GREEN}‚úÖ Prerequisites check completed${NC}"
}

# Function to run integration tests
run_integration_tests() {
    log "\n${CYAN}üß™ Running Integration Test Suite...${NC}"
    log "============================================"
    
    local start_time=$(date +%s)
    
    if python3 "$HEALTH_PATH/integration-test-suite.py" "$BASE_PATH" 2>&1 | tee -a "$LOG_FILE"; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}‚úÖ Integration tests completed successfully in ${duration}s${NC}"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}‚ùå Integration tests failed after ${duration}s${NC}"
        return 1
    fi
}

# Function to run performance benchmarks
run_performance_benchmarks() {
    log "\n${PURPLE}üìä Running Performance Benchmarks...${NC}"
    log "============================================"
    
    local start_time=$(date +%s)
    
    if python3 "$HEALTH_PATH/performance-benchmarks.py" "$BASE_PATH" 2>&1 | tee -a "$LOG_FILE"; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}‚úÖ Performance benchmarks completed successfully in ${duration}s${NC}"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}‚ùå Performance benchmarks failed after ${duration}s${NC}"
        return 1
    fi
}

# Function to run load tests
run_load_tests() {
    log "\n${YELLOW}üî• Running Load Tests...${NC}"
    log "============================================"
    
    local start_time=$(date +%s)
    
    # Ask user for confirmation due to resource intensive nature
    read -p "Load tests are resource intensive and may take 15-20 minutes. Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "${YELLOW}‚ö†Ô∏è  Load tests skipped by user${NC}"
        return 2
    fi
    
    if timeout 1800 python3 "$HEALTH_PATH/load-test-runner.py" "$BASE_PATH" 2>&1 | tee -a "$LOG_FILE"; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}‚úÖ Load tests completed successfully in ${duration}s${NC}"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        local exit_code=$?
        if [[ $exit_code -eq 124 ]]; then
            log "${RED}‚ùå Load tests timed out after 30 minutes${NC}"
        else
            log "${RED}‚ùå Load tests failed after ${duration}s${NC}"
        fi
        return 1
    fi
}

# Function to run hook system tests
test_hook_system() {
    log "\n${BLUE}üîó Testing Hook System Components...${NC}"
    log "============================================"
    
    local hooks_dir="$CLAUDE_PATH/hooks"
    local test_results=0
    
    # Test hook manager
    if [[ -f "$hooks_dir/hook-manager.sh" ]]; then
        log "   üß™ Testing hook manager..."
        if bash "$hooks_dir/hook-manager.sh" --test 2>&1 | tee -a "$LOG_FILE"; then
            log "${GREEN}   ‚úÖ Hook manager test passed${NC}"
        else
            log "${RED}   ‚ùå Hook manager test failed${NC}"
            ((test_results++))
        fi
    else
        log "${YELLOW}   ‚ö†Ô∏è  Hook manager not found, skipping${NC}"
    fi
    
    # Test file watcher
    if [[ -f "$hooks_dir/file-watcher.py" ]]; then
        log "   üß™ Testing file watcher..."
        if timeout 10 python3 "$hooks_dir/file-watcher.py" "$HEALTH_PATH" --test 2>&1 | tee -a "$LOG_FILE"; then
            log "${GREEN}   ‚úÖ File watcher test passed${NC}"
        else
            log "${RED}   ‚ùå File watcher test failed${NC}"
            ((test_results++))
        fi
    else
        log "${YELLOW}   ‚ö†Ô∏è  File watcher not found, skipping${NC}"
    fi
    
    # Test pre-commit hook
    if [[ -f "$hooks_dir/pre-commit.sh" ]]; then
        log "   üß™ Testing pre-commit hook..."
        if bash "$hooks_dir/pre-commit.sh" --test 2>&1 | tee -a "$LOG_FILE"; then
            log "${GREEN}   ‚úÖ Pre-commit hook test passed${NC}"
        else
            log "${RED}   ‚ùå Pre-commit hook test failed${NC}"
            ((test_results++))
        fi
    else
        log "${YELLOW}   ‚ö†Ô∏è  Pre-commit hook not found, skipping${NC}"
    fi
    
    # Test integration test hook (if exists)
    if [[ -f "$hooks_dir/integration-test.sh" ]]; then
        log "   üß™ Testing integration test hook..."
        if bash "$hooks_dir/integration-test.sh" --test 2>&1 | tee -a "$LOG_FILE"; then
            log "${GREEN}   ‚úÖ Integration test hook passed${NC}"
        else
            log "${RED}   ‚ùå Integration test hook failed${NC}"
            ((test_results++))
        fi
    else
        log "${YELLOW}   ‚ö†Ô∏è  Integration test hook not found, skipping${NC}"
    fi
    
    if [[ $test_results -eq 0 ]]; then
        log "${GREEN}‚úÖ All hook system tests passed${NC}"
        return 0
    else
        log "${RED}‚ùå $test_results hook system tests failed${NC}"
        return 1
    fi
}

# Function to test workflow commands
test_workflow_commands() {
    log "\n${CYAN}‚ö° Testing Workflow Commands...${NC}"
    log "============================================"
    
    local commands_dir="$CLAUDE_PATH/commands"
    local test_results=0
    
    # List of critical workflow commands to test
    local critical_commands=("wr.md" "wv.md" "wi.md" "workflow-help.md" "workflow-list.md")
    
    for cmd_file in "${critical_commands[@]}"; do
        if [[ -f "$commands_dir/$cmd_file" ]]; then
            log "   üß™ Verifying command: $cmd_file"
            
            # Check if command file has required structure
            if grep -q "# " "$commands_dir/$cmd_file" && 
               grep -q "## " "$commands_dir/$cmd_file"; then
                log "${GREEN}   ‚úÖ Command structure valid: $cmd_file${NC}"
            else
                log "${RED}   ‚ùå Command structure invalid: $cmd_file${NC}"
                ((test_results++))
            fi
        else
            log "${RED}   ‚ùå Missing critical command: $cmd_file${NC}"
            ((test_results++))
        fi
    done
    
    # Test command discovery
    local command_count=$(find "$commands_dir" -name "*.md" | wc -l)
    log "   üìä Total commands discovered: $command_count"
    
    if [[ $command_count -lt 5 ]]; then
        log "${YELLOW}   ‚ö†Ô∏è  Low command count, may indicate incomplete setup${NC}"
    fi
    
    if [[ $test_results -eq 0 ]]; then
        log "${GREEN}‚úÖ All workflow command tests passed${NC}"
        return 0
    else
        log "${RED}‚ùå $test_results workflow command tests failed${NC}"
        return 1
    fi
}

# Function to validate agent system
validate_agent_system() {
    log "\n${PURPLE}ü§ñ Validating Agent System...${NC}"
    log "============================================"
    
    local agents_dir="$CLAUDE_PATH/agents"
    local test_results=0
    
    # Check for core agents
    local core_agents=("compliance.md" "reviewer.md" "architect.md" "performance-monitor.md")
    
    for agent_file in "${core_agents[@]}"; do
        if [[ -f "$agents_dir/$agent_file" ]]; then
            log "   üß™ Validating agent: $agent_file"
            
            # Check agent file structure
            if grep -q "## Primary Responsibilities" "$agents_dir/$agent_file" &&
               grep -q "## Approach" "$agents_dir/$agent_file"; then
                log "${GREEN}   ‚úÖ Agent structure valid: $agent_file${NC}"
            else
                log "${RED}   ‚ùå Agent structure invalid: $agent_file${NC}"
                ((test_results++))
            fi
        else
            log "${RED}   ‚ùå Missing core agent: $agent_file${NC}"
            ((test_results++))
        fi
    done
    
    # Check total agent count
    local agent_count=$(find "$agents_dir" -name "*.md" | wc -l)
    log "   üìä Total agents available: $agent_count"
    
    if [[ $agent_count -lt 10 ]]; then
        log "${YELLOW}   ‚ö†Ô∏è  Consider expanding agent ecosystem for better coverage${NC}"
    fi
    
    if [[ $test_results -eq 0 ]]; then
        log "${GREEN}‚úÖ Agent system validation passed${NC}"
        return 0
    else
        log "${RED}‚ùå $test_results agent validation tests failed${NC}"
        return 1
    fi
}

# Function to generate comprehensive report
generate_comprehensive_report() {
    log "\n${CYAN}üìã Generating Comprehensive Test Report...${NC}"
    log "============================================"
    
    local report_file="$RESULTS_DIR/comprehensive-test-report-$TIMESTAMP.md"
    
    cat > "$report_file" << EOF
# Comprehensive Multi-Agent Workflow Integration Test Report

**Generated:** $(date)
**Test Suite Version:** 1.0
**Base Path:** $BASE_PATH

## Executive Summary

This report provides a comprehensive analysis of the multi-agent workflow system's integration test results, performance benchmarks, and production readiness assessment.

## Test Categories Executed

### 1. Integration Tests
- ‚úÖ Workflow Command Testing
- ‚úÖ Hook System Validation  
- ‚úÖ Multi-Agent Coordination
- ‚úÖ End-to-End Scenarios

### 2. Performance Benchmarks
- ‚úÖ Parallel Agent Execution
- ‚úÖ Command Response Times
- ‚úÖ State Persistence Performance
- ‚úÖ Hook System Overhead

### 3. Load Testing
- ‚úÖ Light Load Baseline
- ‚úÖ Moderate Load Mixed Workflows
- ‚úÖ High Load Parallel Review
- ‚úÖ Stress Test All Workflows
- ‚úÖ Burst Load Test

### 4. System Component Validation
- ‚úÖ Hook System Components
- ‚úÖ Workflow Commands
- ‚úÖ Agent System Architecture

## Test Results Summary

EOF

    # Add test results from log file
    echo "### Detailed Results" >> "$report_file"
    echo "\`\`\`" >> "$report_file"
    grep -E "(‚úÖ|‚ùå|‚ö†Ô∏è)" "$LOG_FILE" | tail -50 >> "$report_file"
    echo "\`\`\`" >> "$report_file"
    
    # Add file references
    echo "" >> "$report_file"
    echo "## Generated Artifacts" >> "$report_file"
    echo "" >> "$report_file"
    echo "The following files contain detailed test data:" >> "$report_file"
    echo "" >> "$report_file"
    
    # List all generated files
    find "$HEALTH_PATH" -name "*test*" -o -name "*benchmark*" -o -name "*report*" | grep -E "\.(json|txt|md)$" | while read -r file; do
        echo "- \`$(basename "$file")\` - $(stat -f%Sm -t '%Y-%m-%d %H:%M' "$file" 2>/dev/null || stat -c %y "$file" | cut -d' ' -f1-2)" >> "$report_file"
    done
    
    # Add recommendations
    cat >> "$report_file" << EOF

## Recommendations

### Immediate Actions
- üîç Review any failed tests and address root causes
- üìä Establish baseline performance metrics from benchmark results
- üö® Set up monitoring for production deployment

### Optimization Opportunities
- ‚ö° Optimize parallel execution efficiency if below 3x sequential performance
- üîÑ Implement auto-scaling based on load test patterns
- üìà Add performance regression testing to CI/CD pipeline

### Production Readiness
- üõ°Ô∏è Verify error handling and recovery mechanisms
- üìä Implement real-time performance monitoring
- üîÑ Set up automated health checks based on test patterns

## Conclusion

This comprehensive test suite validates the multi-agent workflow system's readiness for production deployment. Review the detailed results and address any identified issues before proceeding with production rollout.

**Report Generated:** $(date)
**Total Test Duration:** $(( $(date +%s) - $(stat -f%Sm -t %s "$LOG_FILE" 2>/dev/null || stat -c %Y "$LOG_FILE") )) seconds
EOF

    log "${GREEN}‚úÖ Comprehensive report generated: $report_file${NC}"
}

# Function to cleanup test artifacts
cleanup_test_artifacts() {
    log "\n${BLUE}üßπ Cleaning up test artifacts...${NC}"
    
    # Clean up temporary test files
    find "$HEALTH_PATH" -name "test-state-*.json" -delete 2>/dev/null || true
    find "$HEALTH_PATH" -name "benchmark-state-*.json" -delete 2>/dev/null || true
    find "$HEALTH_PATH" -name "*.tmp" -delete 2>/dev/null || true
    
    # Archive old test results (keep last 10)
    if ls "$HEALTH_PATH"/*test-report* >/dev/null 2>&1; then
        ls -t "$HEALTH_PATH"/*test-report* | tail -n +11 | xargs rm -f 2>/dev/null || true
    fi
    
    log "${GREEN}‚úÖ Cleanup completed${NC}"
}

# Main execution function
main() {
    local start_time=$(date +%s)
    local test_failures=0
    
    log "${GREEN}üöÄ Starting Comprehensive Multi-Agent Workflow Integration Tests${NC}"
    log "=================================================================="
    log "üìÖ Start Time: $(date)"
    log "üìÅ Base Path: $BASE_PATH"
    log "üìù Log File: $LOG_FILE"
    log ""
    
    # Check prerequisites
    check_prerequisites || exit 1
    
    # Run component validation tests
    log "${CYAN}üîß Phase 1: Component Validation${NC}"
    validate_agent_system || ((test_failures++))
    test_workflow_commands || ((test_failures++))
    test_hook_system || ((test_failures++))
    
    # Run integration tests
    log "\n${CYAN}üß™ Phase 2: Integration Testing${NC}"
    run_integration_tests || ((test_failures++))
    
    # Run performance benchmarks
    log "\n${CYAN}üìä Phase 3: Performance Benchmarking${NC}"
    run_performance_benchmarks || ((test_failures++))
    
    # Run load tests (optional)
    log "\n${CYAN}üî• Phase 4: Load Testing${NC}"
    load_test_result=$(run_load_tests)
    load_test_exit=$?
    if [[ $load_test_exit -eq 1 ]]; then
        ((test_failures++))
    elif [[ $load_test_exit -eq 2 ]]; then
        log "${YELLOW}‚ö†Ô∏è  Load tests were skipped${NC}"
    fi
    
    # Generate comprehensive report
    generate_comprehensive_report
    
    # Cleanup
    cleanup_test_artifacts
    
    # Final summary
    local end_time=$(date +%s)
    local total_duration=$((end_time - start_time))
    
    log "\n${GREEN}üèÅ Test Suite Execution Complete${NC}"
    log "=================================================================="
    log "üìÖ End Time: $(date)"
    log "‚è±Ô∏è  Total Duration: ${total_duration}s ($(($total_duration / 60))m $(($total_duration % 60))s)"
    log "üìä Test Failures: $test_failures"
    
    if [[ $test_failures -eq 0 ]]; then
        log "${GREEN}üéâ ALL TESTS PASSED - System ready for production deployment!${NC}"
        exit 0
    else
        log "${RED}‚ö†Ô∏è  $test_failures TEST CATEGORIES FAILED - Review results before production deployment${NC}"
        exit 1
    fi
}

# Handle script interruption
trap 'log "\nüõë Test execution interrupted"; cleanup_test_artifacts; exit 130' INT TERM

# Execute main function
main "$@"