import { FeedbackItem, FeedbackExport } from '@/types/feedback';

export class FeedbackExporter {
  /**
   * Export feedback to markdown format optimized for Claude Code
   */
  exportToMarkdown(items: FeedbackItem[], sessionId: string): string {
    if (items.length === 0) return '';

    const now = new Date();
    const groupedByPage = this.groupByPage(items);
    const groupedByComponent = this.groupByComponent(items);

    let markdown = `# Visual Feedback Report\n\n`;
    markdown += `**Generated**: ${now.toLocaleString()}\n`;
    markdown += `**Session ID**: ${sessionId}\n`;
    markdown += `**Total Items**: ${items.length}\n`;
    markdown += `**Pages**: ${Object.keys(groupedByPage).length}\n\n`;

    // Summary by priority
    const highPriority = items.filter(i => i.feedback.priority === 'high').length;
    const mediumPriority = items.filter(i => i.feedback.priority === 'medium').length;
    const lowPriority = items.filter(i => i.feedback.priority === 'low').length;

    if (highPriority > 0 || mediumPriority > 0) {
      markdown += `## Priority Summary\n\n`;
      if (highPriority > 0) markdown += `- ðŸ”´ **High Priority**: ${highPriority} items\n`;
      if (mediumPriority > 0) markdown += `- ðŸŸ¡ **Medium Priority**: ${mediumPriority} items\n`;
      if (lowPriority > 0) markdown += `- ðŸŸ¢ **Low Priority**: ${lowPriority} items\n`;
      markdown += '\n';
    }

    // Group by component if available
    const componentsWithPaths = Object.entries(groupedByComponent).filter(
      ([name]) => name !== 'Unknown Component'
    );

    if (componentsWithPaths.length > 0) {
      markdown += `## Changes by Component\n\n`;
      
      for (const [componentName, componentItems] of componentsWithPaths) {
        const componentPath = componentItems[0].element.componentPath;
        markdown += `### ${componentName}`;
        if (componentPath) {
          markdown += ` (\`${componentPath}\`)`;
        }
        markdown += '\n\n';

        componentItems.forEach((item, index) => {
          markdown += this.formatFeedbackItem(item, index + 1, true);
        });
      }
    }

    // Then list by page
    markdown += `## Changes by Page\n\n`;
    
    for (const [page, pageItems] of Object.entries(groupedByPage)) {
      markdown += `### Page: ${page}\n\n`;
      
      // Sort by priority
      const sorted = this.sortByPriority(pageItems);
      
      sorted.forEach((item, index) => {
        markdown += this.formatFeedbackItem(item, index + 1, false);
      });
    }

    // Implementation guide
    markdown += `## Implementation Guide\n\n`;
    markdown += `To apply these changes in Claude Code:\n\n`;
    markdown += `1. Copy this entire report\n`;
    markdown += `2. In Claude Code, use: \`/apply-feedback\`\n`;
    markdown += `3. Paste the report when prompted\n`;
    markdown += `4. Review the proposed changes\n`;
    markdown += `5. Approve to apply automatically\n\n`;

    markdown += `---\n\n`;
    markdown += `*Generated by Visual Feedback System*\n`;

    return markdown;
  }

  /**
   * Export feedback to JSON format
   */
  exportToJSON(items: FeedbackItem[], sessionId: string): string {
    const exportData: FeedbackExport = {
      version: '1.0.0',
      session: sessionId,
      timestamp: new Date().toISOString(),
      pages: [...new Set(items.map(item => item.page))],
      totalItems: items.length,
      feedback: items,
    };

    return JSON.stringify(exportData, null, 2);
  }

  /**
   * Export to a combined format with both markdown and JSON
   */
  exportCombined(items: FeedbackItem[], sessionId: string): string {
    const markdown = this.exportToMarkdown(items, sessionId);
    const json = this.exportToJSON(items, sessionId);

    return `${markdown}\n\n## Raw JSON Data\n\n\`\`\`json\n${json}\n\`\`\``;
  }

  /**
   * Format a single feedback item for markdown
   */
  private formatFeedbackItem(item: FeedbackItem, index: number, compact: boolean = false): string {
    let output = '';
    
    const priorityEmoji = {
      high: 'ðŸ”´',
      medium: 'ðŸŸ¡',
      low: 'ðŸŸ¢',
    };

    const typeEmoji = {
      style: 'ðŸŽ¨',
      content: 'ðŸ“',
      behavior: 'âš¡',
      layout: 'ðŸ“',
      feature: 'âœ¨',
    };

    if (!compact) {
      output += `#### Feedback #${index}\n\n`;
    } else {
      output += `**${index}.** `;
    }

    // Priority and type indicators
    output += `${priorityEmoji[item.feedback.priority]} ${typeEmoji[item.feedback.type]} `;
    
    if (!compact) {
      output += `**${item.feedback.type}** (${item.feedback.priority} priority)\n\n`;
      
      // Component info
      if (item.element.componentName) {
        output += `**Component**: ${item.element.componentName}`;
        if (item.element.componentPath) {
          output += ` (\`${item.element.componentPath}\`)`;
        }
        output += '\n';
      }
      
      // Element selector
      output += `**Element**: \`${item.element.selector}\`\n\n`;
      
      // Description
      output += `**Change Required**:\n${item.feedback.description}\n\n`;
      
      // Current state (if we have Tailwind classes)
      if (item.element.tailwindClasses && item.element.tailwindClasses.length > 0) {
        output += `**Current Classes**:\n\`\`\`\n${item.element.tailwindClasses.join(' ')}\n\`\`\`\n\n`;
      }
      
      // Suggested implementation
      if (item.feedback.suggestedChange) {
        output += `**Suggested Implementation**:\n\`\`\`\n${item.feedback.suggestedChange}\n\`\`\`\n\n`;
      }
      
      // Separator
      output += '---\n\n';
    } else {
      // Compact format for component view
      output += `${item.feedback.description}`;
      if (item.feedback.suggestedChange) {
        output += ` â†’ \`${item.feedback.suggestedChange}\``;
      }
      output += '\n';
    }

    return output;
  }

  /**
   * Group feedback items by page
   */
  private groupByPage(items: FeedbackItem[]): Record<string, FeedbackItem[]> {
    return items.reduce((acc, item) => {
      if (!acc[item.page]) acc[item.page] = [];
      acc[item.page].push(item);
      return acc;
    }, {} as Record<string, FeedbackItem[]>);
  }

  /**
   * Group feedback items by component
   */
  private groupByComponent(items: FeedbackItem[]): Record<string, FeedbackItem[]> {
    return items.reduce((acc, item) => {
      const componentName = item.element.componentName || 'Unknown Component';
      if (!acc[componentName]) acc[componentName] = [];
      acc[componentName].push(item);
      return acc;
    }, {} as Record<string, FeedbackItem[]>);
  }

  /**
   * Sort items by priority
   */
  private sortByPriority(items: FeedbackItem[]): FeedbackItem[] {
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    return [...items].sort((a, b) => {
      return priorityOrder[a.feedback.priority] - priorityOrder[b.feedback.priority];
    });
  }

  /**
   * Generate actionable tasks for Claude Code
   */
  generateTasks(items: FeedbackItem[]): string[] {
    const tasks: string[] = [];
    const componentMap = this.groupByComponent(items);

    for (const [component, componentItems] of Object.entries(componentMap)) {
      if (component === 'Unknown Component') continue;

      const path = componentItems[0].element.componentPath;
      const changes = componentItems.map(item => ({
        type: item.feedback.type,
        description: item.feedback.description,
        suggestion: item.feedback.suggestedChange,
      }));

      if (path) {
        tasks.push(`Update ${component} at ${path}:`);
        changes.forEach(change => {
          tasks.push(`  - ${change.description}`);
          if (change.suggestion) {
            tasks.push(`    Implementation: ${change.suggestion}`);
          }
        });
      }
    }

    return tasks;
  }
}